---
title: "scRNAseq Interstitial cells : cluster attribution"
author: "Marion Hardy"
date: "`r Sys.Date()`"
output: 
  html_document: 
    toc: yes
    theme: spacelab
    highlight: monochrome
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, cache = T, echo = FALSE, warning = F, cache.lazy = F)
knitr::opts_chunk$set(fig.width=10, fig.height=8) 

library(tidyverse)
library(openxlsx)
library(Seurat)
library(scCustomize)
```

# Introduction

**This assumes you have run the** "interstitial_report1.Rmd" document and generated the seurat_f and seurat_r objects.

Data from our collaborator Panagiotis rds file for a
SingleCellExperiment object containing the single cell data for **the
interstitial cells** of *Hydra Vulgaris* during multiples stages of
regeneration after bisection:

<https://www.dropbox.com/scl/fi/dg76sigjnj5u6qr06xk79/sce_interstitial_Juliano.rds?rlkey=f0y3lqt0wdcwq652zisnrpf9t&dl=0>

BUT they mapped it to *Hydra Magnipapillata (105)* "Drop-seq reads from
15 libraries generated for Hydra vulgaris strain AEP were mapped to the
2.0 genome assembly of closely related Hydra vulgaris strain 105
(available at <https://research.nhgri.nih.gov/hydra/>) and processed
using the Hydra 2.0 gene models. Strain Hydra vulgaris 105 was formerly
referred to as Hydra magnipapillata 105."

The coldata of the object contain cell annotation including

-   quality metrics: nFeature nCount (not MT percentage interestingly)

-   batch info: either 2869 (3162 barcodes), 3113 (10352 barcodes), 3271
    (13279 barcodes), 3357 (3875 barcodes)

-   originating experiments (head or foot regeneration)

-   experimental time points

-   pseudo-axis assignment (vals.axis ranging from 0-1, increasing in
    the foot-tentacle direction)

-   mitotic and apoptotic signatures indices from 0 to 1

The rowdata contains gene annotation, using Entrez-gene identifiers. I
have also noticed that in the sce objects there's

-   PCA, tSNE and UMAP coordinates for reduced dimensions + corrected
    for batch values

-   assay metafeatures hold gene_id, product, gene, is.rib.prot.gene
    (T/F), HypoMarkers (T/F), ccyle (T/F), apopt (T/F) etc

I converted the sce objects 6.6gb into a seurat object 2.2 gb and
checked that all cited parameters could be found in it.

# Data loading

Which dataset set should I use? Batch regressed looks weird but might be interesting depending on how timepoints end up clustering...

Let's make a UMAP with timepoints as labels.
I am using the scaled and batch regressed data.

```{r}
# seurat objects
seurat_f = readRDS("data_output/interstitial/seurat_filtered.rds")
seurat_r = readRDS("data_output/interstitial/seurat_filtered_regressed.rds")

# 105 genome annotations
annot = read.xlsx("./data/mcbi_dataset_MH_annotated.xlsx")
annot$Symbol_updated = as.character(annot$Symbol_updated)


# set up to split the object per head or foot
footcond = c("REG_FOOT_t0","REG_FOOT_t6","REG_FOOT_t12","REG_FOOT_t24",
             "REG_FOOT_t48","REG_FOOT_t96")
seurat_r$axis <- ifelse(test = seurat_r$EXP_TIME %in% footcond, yes = "Foot", no = "Head")

# changing labeled time from t6 to t06 so thqt it orders properly in the plots

Idents(seurat_r) = "EXP_TIME"
seurat_r = RenameIdents(seurat_r, "REG_FOOT_t6" = "REG_FOOT_t06")  
seurat_r = RenameIdents(seurat_r, "REG_HEAD_t6" = "REG_HEAD_t06")  

```

# Subsetting by head/foot and timepoint for both regressed and unregressed
## Not batch regressed

```{r}

Idents(seurat_f) = "EXP_TIME"
DimPlot(seurat_f, label = FALSE)

# Creating the head and foot data subset
hfootf = subset(seurat_f, subset = EXP == "REG_FOOT")
hheadf = subset(seurat_f, subset = EXP == "REG_HEAD")

```

```{r, fig.width=30, fig.height=6}

# Plotting conditions separately

Idents(hfootf) = hfootf@meta.data$SCT_snn_res.0.025
Idents(hheadf) = hheadf@meta.data$SCT_snn_res.0.025

DimPlot(hfootf, reduction = "umap", split.by = "EXP_TIME", pt.size = 2)

DimPlot(hheadf, reduction = "umap", split.by = "EXP_TIME", pt.size = 2)

```


We don't really see time-dependent clustering here.

## Batch regressed

```{r}

Idents(seurat_r) = "EXP_TIME"
DimPlot(seurat_r, label = FALSE)

# Creating the head and foot data subset
hfoot = subset(seurat_r, subset = axis == "Foot")
hhead = subset(seurat_r, subset = axis == "Head")

```

```{r, fig.width=30, fig.height=6}

# Plotting conditions separately

Idents(hfoot) = hfoot@meta.data$SCT_snn_res.0.025
Idents(hhead) = hhead@meta.data$SCT_snn_res.0.025

DimPlot(hfoot, reduction = "umap", split.by = "EXP_TIME", pt.size = 2)

DimPlot(hhead, reduction = "umap", split.by = "EXP_TIME", pt.size = 2)

```

There's much more time dependent-clustering happening here.
I will move forward with the regressed data unless told otherwise.

# Cluster attribution
## UMAP at 0.025 resolution

```{r, fig.width=8, fig.height=6}

Idents(seurat_r) = "SCT_snn_res.0.025"

DimPlot(seurat_r, label = TRUE)+
  labs(title = "Resolution = 0.025")

```

## Finding markers per clusters

```{r, eval=FALSE} 
# Find markers for each clusters------------------------------------------------

# With the ` FindAllMarkers()` function we are comparing 
# each cluster against all other clusters to identify potential marker genes. 
# The cells in each cluster are treated as replicates, and essentially a 
# differential expression analysis is performed with some statistical test.
# By default, it's a wilcoxon rank sum test

# Seurat lab suggested that DE analysis on obj@assay$RNA@data, which is normalized data (not scaled). So you are right, you should NormalizeData and then FindMarkers. However, Seurat 4 (not sure which small version exactly) starts to promotes DE analysis on obj@assay$SCT@scale.data, which is person residual. My experience is to try both and take the one that fits your goal because Seurat said both are not incorrect.

# DO NOT RUN THIS COMMAND IF YOU'VE ALREADY DONE IT ONCE, THIS CHUNK IS EVAL = FALSE
markers = FindAllMarkers(object = seurat_r,
                         logfc.threshold = 0.5,
                         assay = "SCT",
                         slot = "scale.data")

```

```{r}
markers = read.csv("./data_output/interstitial/markers_diff_per_cluster.csv")%>% 
  filter(p_val_adj < 0.05)

# write.csv(markers, "./data_output/interstitial/markers_diff_per_cluster.csv")

markers$gene = as.character(markers$gene)
```

### Markers that seem specific to cluster identity.

```{r}
head(markers)
```

```{r, , fig.width=15, fig.height=10}

target = markers %>% 
  group_by(cluster) %>%
  top_n(n = 5, wt = avg_diff) 

target = 
  target %>% 
  filter(!duplicated(gene))

target = target[!duplicated(target$gene),] 


# Sooo turns out i'm gonna have to manually give these important genes symbols
# so they become readable on a graph


dp = DotPlot_scCustom(seurat_r, features = target$gene, 
                      colors_use = viridis_plasma_dark_high,
                      x_lab_rotate = T)+
  labs(title = "Dotplot for top 5 differentially expressed genes per cluster")

dp

```


```{r, warning=TRUE, fig.width=5, fig.height=4}

theo = read.xlsx("./data/mcbi_dataset_MH_annotated.xlsx", sheet = "celltype_markers")

# Sooo turns out i'm gonna have to manually give these important genes symbols
# so they become readable on a graph


dp = DotPlot_scCustom(seurat_r, features = theo$Symbol, 
                      colors_use = viridis_plasma_dark_high,
                      x_lab_rotate = T)+
  labs(title = "Dotplot for literature markers")

dp

```


```{r, fig.height=12, fig.width=8}

Clustered_DotPlot(seurat_r, features = target$gene)

```


```{r, eval=FALSE}

target <- c("100215682") # its bcl-2

FeaturePlot(object = seurat_r, 
            features = target,
            reduction = "umap",
            sort.cell = TRUE,
            min.cutoff = 'q10', 
            label = TRUE,
            repel = TRUE,
            pt.size = 0.75)

```


```{r, eval=FALSE}
## Juliette and Chim-Kei's questions--------------------------------------------

# In which clusters are ROR2 etc expressed?

target <- c("ROR2","ROR1","STAT1","STAT3","CTNNB1")

FeaturePlot(object = seurat_r, 
            features = target,
            reduction = "tsne",
            sort.cell = TRUE,
            min.cutoff = 'q10', 
            label = TRUE,
            repel = TRUE)

ggsave(paste0(lnames[i],"_ROR2_tSNE.png"),last_plot(),"./figures/GSE144236/", dpi = 500,
       width = 9, height = 9,
       device = "png")

VlnPlot(object = seurat_r, features = target)

ggsave(paste0(lnames[i],"_ROR2_violin_plot.png"),last_plot(),"./figures/GSE144236/", device = png, 
       dpi = 500, width = 9, height = 5)


# Markers for celltype identification

celltype <- c("KRT1","KRT5","KRT10","KRT14","LYZ","HLA-DRB1", "HLA-DRA","HLA-DQB2",
              "CD3D", "CD2","CD7","COL1A1", "COL1A2","LUM","MLANA", "DCT", "PMEL",
              "TFF3", "CLDN5", "VWF", "IGLL5", "IGJ"," MS4A1", "CD79A","CD163",
              "CD68","S100A8"," S100A9", "TREM1","CD1C", "CLEC10A","CLEC9A", "CADM1", 
              "XCR1", "CD207", "CD1A", "S100B","AXL", "IGFBP5", "PPP1R14A","CLEC4C",
              "IL3RA","CCR7", "CCL19","CD4","CD8")

dp <- DotPlot(seurat_r, features = celltype, cols = c("red","blue"))
dp

# Do it with complexheatmap

df <- dp$data

# the matrix for the scaled expression 
exp_mat<-df %>% 
  select(-pct.exp, -avg.exp) %>%  
  pivot_wider(names_from = id, values_from = avg.exp.scaled) %>% 
  as.data.frame() 

row.names(exp_mat) <- exp_mat$features.plot  
exp_mat <- exp_mat[,-1] %>% as.matrix()

head(exp_mat)

## the matrix for the percentage of cells express a gene

percent_mat<-df %>% 
  select(-avg.exp, -avg.exp.scaled) %>%  
  pivot_wider(names_from = id, values_from = pct.exp) %>% 
  as.data.frame() 

row.names(percent_mat) <- percent_mat$features.plot  
percent_mat <- percent_mat[,-1] %>% as.matrix()

head(percent_mat)

Polychrome::swatch(viridis(20))

## any value that is greater than 2 will be mapped to yellow
col_fun = circlize::colorRamp2(c(-1, 0, 2), viridis(20)[c(1,10, 20)])


cell_fun = function(j, i, x, y, w, h, fill){
  grid.rect(x = x, y = y, width = w, height = h, 
            gp = gpar(col = NA, fill = NA))
  grid.circle(x=x,y=y,r= percent_mat[i, j]/100 * min(unit.c(w, h)),
              gp = gpar(fill = col_fun(exp_mat[i, j]), col = NA))}

reso <- 1200
length <- 3.25*reso/72

png(filename =paste0("./figures/GSE144236/heatmap",lnames[i],".png"))

plot <- Heatmap(exp_mat,
        heatmap_legend_param=list(title="expression"),
        column_title = "clustered dotplot", 
        col=col_fun,
        rect_gp = gpar(type = "none"),
        cell_fun = cell_fun,
        row_names_gp = gpar(fontsize = 5),
        row_km = 4,
        border = "black")
print(plot)
dev.off() 

```






# Session info

```{r}
sessionInfo()
```
