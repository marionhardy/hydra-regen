---
title: "scRNAseq Interstitial cells"
author: "Marion Hardy"
date: "`r Sys.Date()`"
output: 
  html_document: 
    toc: yes
    theme: spacelab
    highlight: monochrome
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, cache = T, echo = FALSE, warning = F, cache.lazy = F)
knitr::opts_chunk$set(fig.width=10, fig.height=8) 

library(tidyverse)
library(Seurat)
library(openxlsx)
```

# Introduction

Data from our collaborator Panagiotis rds file for a
SingleCellExperiment object containing the single cell data for **the
interstitial cells** of *Hydra Vulgaris* during multiples stages of
regeneration after bisection:

<https://www.dropbox.com/scl/fi/dg76sigjnj5u6qr06xk79/sce_interstitial_Juliano.rds?rlkey=f0y3lqt0wdcwq652zisnrpf9t&dl=0>

BUT they mapped it to *Hydra Magnipapillata (105)* "Drop-seq reads from
15 libraries generated for Hydra vulgaris strain AEP were mapped to the
2.0 genome assembly of closely related Hydra vulgaris strain 105
(available at <https://research.nhgri.nih.gov/hydra/>) and processed
using the Hydra 2.0 gene models. Strain Hydra vulgaris 105 was formerly
referred to as Hydra magnipapillata 105."

The coldata of the object contain cell annotation including

-   quality metrics: nFeature nCount (not MT percentage interestingly)

-   batch info: either 2869 (3162 barcodes), 3113 (10352 barcodes), 3271
    (13279 barcodes), 3357 (3875 barcodes)

-   originating experiments (head or foot regeneration)

-   experimental time points

-   pseudo-axis assignment (vals.axis ranging from 0-1, increasing in
    the foot-tentacle direction)

-   mitotic and apoptotic signatures indices from 0 to 1

The rowdata contains gene annotation, using Entrez-gene identifiers. I
have also noticed that in the sce objects there's

-   PCA, tSNE and UMAP coordinates for reduced dimensions + corrected
    for batch values

-   assay metafeatures hold gene_id, product, gene, is.rib.prot.gene
    (T/F), HypoMarkers (T/F), ccyle (T/F), apopt (T/F) etc

I converted the sce objects 6.6gb into a seurat object 2.2 gb and
checked that all cited parameters could be found in it.

# Data loading

```{r}

# int = readRDS("./data/sce_interstitial_Juliano.rds")
# seurat = as.Seurat(int, counts = "counts", data=NULL)

seurat = readRDS("data/seurat.Rds")

# Update the gene names in the count matrix
# I updated the gene names when they were determined to be gene of interest 
# in downstream analyses + cell type markers

annot = read.xlsx("./data/mcbi_dataset_MH_annotated.xlsx")
annot$Symbol[] <- lapply(annot$Symbol, function(x) sub("LOC", "", x, fixed = TRUE)) # removing the LOC prefix
annot$Symbol_updated[] <- lapply(annot$Symbol_updated, function(x) sub("LOC", "", x, fixed = TRUE)) # removing the LOC prefix
annot$Symbol = unlist(annot$Symbol) # unlisting it to look like a mormal column
annot$Symbol_updated = unlist(annot$Symbol_updated)

temp = data.frame(orig_gene = rownames(seurat))
temp2 = data.frame(updated = annot$Symbol_updated,
                   orig_gene = annot$Symbol) %>% 
  filter(!duplicated(updated))

# if temp2$updated is NA, fill with temp1

temp3 = left_join(temp, temp2) # now temp3 is ordered like the genes in seurat

temp3 = 
  temp3 %>%
  mutate(updated = coalesce(updated,orig_gene)) #works

seurat@assays$originalexp@counts@Dimnames[[1]] <- temp3$updated
seurat@assays$originalexp@data@Dimnames[[1]] <- temp3$updated
seurat@assays$originalexp@meta.features = annot

```

```{r, echo=TRUE}

head(seurat@meta.data)
table(seurat@meta.data$batch, seurat@meta.data$EXP_TIME)

```

# QC

## No filtering applied

The gene names looking like LOC1248.... are actually all symbols of
unnamed regions If you go through the list of genes seen, none of them
are mitochondrial but they do have descriptions

-   This data probably should be aligned on the matching genome

-   Why are there no mitochondrial genes in the Hydra_05_v3 construct?

Annotations can be found here:
<https://www.ncbi.nlm.nih.gov/datasets/gene/GCF_022113875.1/>

This means that I cannot regress out the variability that comes from the
presence of mitochondrial genes since it seems like there aren't any. I
can still regress out a possible batch effect though.

```{r, echo=TRUE}

head(seurat@assays[["originalexp"]]@meta.features) # none of the genes start with "mt"

```

```{r, fig.width=8, fig.height=5}

# QC and filtering -------------------------------------------------------------

# How I would usually calculate mitochondrial percentage
# seurat$mitoPercent = PercentageFeatureSet(seurat, pattern='^mt-')
# head(seurat@meta.data) # we now have the mitopercent added to the metadata

# Just like Cell Ranger output, feature in the following results represents gene. 
# nFeature_ is the number of genes detected in each cell. nCount_ is the 
# total number of molecules detected within a cell.

Idents(seurat) = seurat@meta.data$batch
VlnPlot(seurat, features = c("nFeature_originalexp", "nCount_originalexp"), 
              ncol = 2, pt.size = 0.0001, split.by = 'batch')

# FeatureScatter is typically used to visualize feature-feature relationships, but can be used
# for anything calculated by the object, i.e. columns in object metadata, PC scores etc.

FeatureScatter(seurat, feature1 = "nCount_originalexp", feature2 = "nFeature_originalexp") + 
  theme(legend.position="none") # 0.91 show correlations between features and gene counts

```

0.91 for correlation between nFeature and nCount is a good score. As a
reminder, nFeature is number of unique RNAs (gene that matched at least
one UMI) found in a droplet and nCount is number of total molecules
found in a droplet. Ideally they'd be exactly proportional?

## Filtering applied

Here, we filter away cells that have unique feature counts(genes) over
6000 or less than 200. Too many features could indicate a doublet too
little might indicate an empty droplet

We should also filter away cells that have \> 10% mitochondrial counts

```{r, fig.width=8, fig.height=5}

# Here, we filter away cells that have unique feature counts(genes) over 6000 
# or less than 200. Too many features could indicate a doublet too little might indicate an empty droplet
# We should also filter away cells that have > 10% mitochondrial counts

seurat_f = subset(seurat, subset = nFeature_originalexp > 200 & nFeature_originalexp < 6000)

VlnPlot(seurat_f, features = c("nFeature_originalexp", "nCount_originalexp"), 
              ncol = 2, pt.size = 0.0001, split.by = 'batch' )

FeatureScatter(seurat_f, feature1 = "nCount_originalexp", feature2 = "nFeature_originalexp") + 
  theme(legend.position="none")

```

# Normalization/scaling

SCTransform is better than using the standard (old) normalization
pipeline because it does negative binomial regression (just as DESeq2
does for RNAseq) which does variance regression that normalization did
not do\>

"...omits the need for heuristic steps including pseudocount addition or
log-transformation" -satijalab

Interestingly, regressing out the batches lead to more distinct cell populations on the PCA.

```{r, fig.width=4, fig.height=4, echo=FALSE}

seurat_r = SCTransform(seurat_f, assay = "originalexp", vars.to.regress = "batch") 
seurat_f = SCTransform(seurat_f, assay = "originalexp") 

# These are now standard steps in the Seurat workflow for visualization and clustering

Idents(seurat_f) = seurat_f@meta.data$batch
seurat_f <- RunPCA(seurat_f, features = VariableFeatures(object = seurat_f))
DimPlot(seurat_f, reduction = "pca")+
  labs(title = "Not regressed")

Idents(seurat_r) = seurat_r@meta.data$batch
seurat_r <- RunPCA(seurat_r, features = VariableFeatures(object = seurat_r))
DimPlot(seurat_r, reduction = "pca")+
  labs(title = "Batch regressed")
```

```{r, fig.width=4, fig.height=8}

DimHeatmap(seurat_r, dims = 1:30, cells = 500, balanced = TRUE)
# So I'll run it on the first 28 pc
```

### Not regressed

```{r, fig.width=6, fig.height=5}

seurat_f <- RunUMAP(seurat_f, dims = 1:28, seed.use = 054057)
DimPlot(seurat_f, reduction = "umap")


seurat_f <- FindNeighbors(seurat_f, dims = 1:28)

seurat_f <- FindClusters(seurat_f, resolution = 0.025)
DimPlot(seurat_f, label = TRUE)+
  labs(title = "Resolution = 0.025")


seurat_f <- FindClusters(seurat_f, resolution = 0.1)
DimPlot(seurat_f, label = TRUE)+
  labs(title = "Resolution = 0.1")


seurat_f <- FindClusters(seurat_f, resolution = 0.3)
DimPlot(seurat_f, label = TRUE)+
  labs(title = "Resolution = 0.3")

```


### Batch regressed

```{r, fig.width=6, fig.height=5}

seurat_r <- RunUMAP(seurat_r, dims = 1:28, seed.use = 054057)
DimPlot(seurat_r, reduction = "umap")


seurat_r <- FindNeighbors(seurat_r, dims = 1:28)

seurat_r <- FindClusters(seurat_r, resolution = 0.025)
DimPlot(seurat_r, label = TRUE)+
  labs(title = "Resolution = 0.025")


seurat_r <- FindClusters(seurat_r, resolution = 0.1)
DimPlot(seurat_r, label = TRUE)+
  labs(title = "Resolution = 0.1")


seurat_r <- FindClusters(seurat_r, resolution = 0.3)
DimPlot(seurat_r, label = TRUE)+
  labs(title = "Resolution = 0.3")

```


```{r, eval = FALSE}
write_rds(seurat_f, "./data_output/interstitial/seurat_filtered.rds")
write_rds(seurat_r, "./data_output/interstitial/seurat_filtered_regressed.rds")
```

# Session info

```{r}
sessionInfo()
```
